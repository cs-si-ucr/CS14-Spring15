{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to CS14 SI!\n\n\nThis is where all of the labs will be posted.\n\n\nWhat is SI?\n\n\nSupplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.\n\n\nWhat isn\u2019t SI?\n\n\nSupplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.\n\n\nWho should go?\n\n\nAnyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.\n\n\nHowever, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.\n\n\nWith that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.\n\n\nGuidelines:\n\n\n\n\nBe respectful - This includes silencing your cell phones\nand not using them during sessions.\n\n\nParticipate - You won\u2019t get very much out of SI if you\ndon\u2019t.\n\n\nNo food or drink besides water - This is a rule placed\nby the administration. I will enforce it.\n\n\nLate entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.\n\n\nSign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-cs14-si", 
            "text": "This is where all of the labs will be posted.", 
            "title": "Welcome to CS14 SI!"
        }, 
        {
            "location": "/#what-is-si", 
            "text": "Supplemental Instruction is a series of weekly review sessions for students\ntaking historically difficult courses. It offers students the chance to\ncollaborate, discuss challenging concepts, and study for exams.", 
            "title": "What is SI?"
        }, 
        {
            "location": "/#what-isnt-si", 
            "text": "Supplemental Instruction is not a lecture. SI Leaders are not there to teach you new material but to lead you in reviewing the material covered in lecture\nand to help guide you in understanding the subject.", 
            "title": "What isn\u2019t SI?"
        }, 
        {
            "location": "/#who-should-go", 
            "text": "Anyone who has the time to spare; whether you have been programming on the\nside for a number of years or if your only experience with computers is\nwriting essays and checking Facebook, I promise you I will be able to help you\nlearn something new that will help your perform better in the course.  However, if you are having trouble in the class or think you might run into\ntrouble, you should definitely attend. CS 10 has a high dropout rate, along\nwith a high failure rate, so if you are running into trouble, let me help you.\nDo not be intimidated if you are trying to start coming later in the quarter\n(though try not to wait that long), I will help bring you up to speed.  With that in mind, I should mention that SI is required for learning community\nstudents. If you are not attending, you will be dropped from your learning\ncommunity.", 
            "title": "Who should go?"
        }, 
        {
            "location": "/#guidelines", 
            "text": "Be respectful - This includes silencing your cell phones\nand not using them during sessions.  Participate - You won\u2019t get very much out of SI if you\ndon\u2019t.  No food or drink besides water - This is a rule placed\nby the administration. I will enforce it.  Late entry and early exit should be quiet - I realize\neveryone\u2019s schedules are different. However, please do not\nenter or leave in such a way that draws everyone\u2019s\nattention to you.  Sign in - There will usually be a working computer for\nyou to sign into when you arrive. Please use it to check in\n(even if you\u2019re not on time).", 
            "title": "Guidelines:"
        }, 
        {
            "location": "/lab_week_01/", 
            "text": "Lab 1: Templates\n\n\nYou may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".\n\n\nIn order to implement a Linked List, you must define the structure\nfor an individual node. \n\n\nFor a singly-linked list of integers, it may look something like:\n\n\nstruct IntNode{\n    int val;\n    IntNode * next;\n};\n\n\n\n\nIn order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a \nIntNode\n. We also implement methods that\ninsert/remove elements from the list\ne.g.\n\n\nclass IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};\n\n\n\n\nThat's all fine and dandy, but if instead want a \nDoubleList\n or a\n\nStringList\n, then we are in trouble. \n\n\nA common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to \nmake mistakes\n\ncopy and pasting.\n\n\nIntroducing templates!\n\n\nThe solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.\n\n\nIn fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.\n\n\nTo create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".\n\n\nvector\nint\n numbers; // creates a vector of integers\nvector\nstring\n words; // creates a vector of strings\n\n\n\n\nTo create a new class template, before our class declaration we use the keyword \ntemplate\n followed by a type parameter inside \"angle-brackets\"\ne.g. \ntemplate\ntypename T\n. The keyword \ntypename\n tells the compiler\nthat \nT\n is a placeholder for an actual type. \n\n\nNote: \nT\n is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is \nContainer\n\n\nLet's say, we want to create a templated version of our Node and List.\n\n\nIntNode\n becomes:\n\n\ntemplate\ntypename T\n\nstruct Node {\n   T val;\n   Node\nT\n * next;\n};\n\n\n\n\nand \nIntLinkedList\n becomes:\n\n\ntemplate\ntypename T\n\nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node\nT\n * head;\n};\n\n\n\n\nTo create a \nLinkedList\n of doubles, we declare the list as so:\n\n\nLinkedList\ndouble\n list;\n\n\n\n\nIn order to template functions and method, we do something similar.\n\n\nFor example, if we want to define the templated LinkedList's\n\npush_front\n method:\n\n\ntemplate\ntypename T\n\nLinkedList\nT\n::push_front(T val) {\n    Node * new_node = new Node\nT\n();\n    new_node -\n val = val;\n\n    Node * old_head = this -\n head;\n    new_node -\n next = old_head;\n    this -\n head = new_node;\n}\n\n\n\n\nFor more info on templates check out \nthis FAQ\n!\n\n\nExercises\n\n\nImplement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier! \n\n\nPro-Tip: before implementing the class as a class template, \ntypedef\n the type \nT\n as an integer and replace type with \nT\n as needed.\n\ne.g.\n\n\ntypedef int T; // give the int an alias which is T\nT my_int = 42;\n\n\n\n\nThis give you much nicer error messages and makes it easier to debug.\n\n\nExample Usage, should implement at least the following methods:\n\n\nMyVector\nstring\n vec;\nvec.push_back(\nCS14\n);\nvec.push_back(\nWorld\n);\nvec.insert(\nHello\n, 0); \ncout \n vec.front() \n endl; // \nHello\n\ncout \n vec.back() \n endl; // \nWorld\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nCS14\n\nvec.pop_back();\ncout \n vec.back() \n endl; // \nHello\n\n\nMyVector\nint\n another_vec;\nanother_vec.push_back(42);\n\n\n\n\nStretch-goal exercise:\n\n\nRewrite your IntList as a class template!", 
            "title": "Lab Week 1"
        }, 
        {
            "location": "/lab_week_01/#lab-1-templates", 
            "text": "You may remember (or should remember) from CS12 a data structure\nthat is formed by connecting a group of nodes called a \"Linked List\".  In order to implement a Linked List, you must define the structure\nfor an individual node.   For a singly-linked list of integers, it may look something like:  struct IntNode{\n    int val;\n    IntNode * next;\n};  In order to implement the Linked List, we store the head of the list,\nwhich is a pointer to a  IntNode . We also implement methods that\ninsert/remove elements from the list\ne.g.  class IntLinkedList {\n    public:\n        void push_front(int val);\n        // ...\n    private:\n        IntNode * head;\n};  That's all fine and dandy, but if instead want a  DoubleList  or a StringList , then we are in trouble.   A common first instinct is to copy-and-paste code manually \nand change the types where needed. But even expert programmers \nstart to  make mistakes \ncopy and pasting.", 
            "title": "Lab 1: Templates"
        }, 
        {
            "location": "/lab_week_01/#introducing-templates", 
            "text": "The solution for this problem is function-templates and class-templates which in a way generate this \"copy-and-paste\" code for you.  In fact, you've already been using templates all-along. The standard\nlibrary container, vector, which makes dynamic arrays easy to use is\nalso one of these template classes.  To create an instance of a template class is simple, just provide the\ndesired type in the \"angle-brackets\".  vector int  numbers; // creates a vector of integers\nvector string  words; // creates a vector of strings  To create a new class template, before our class declaration we use the keyword  template  followed by a type parameter inside \"angle-brackets\"\ne.g.  template typename T . The keyword  typename  tells the compiler\nthat  T  is a placeholder for an actual type.   Note:  T  is a common name for a placeholder type, this name like parameter names should be a tell for how the class is used - e.g. a common typename for classes that take in any container such as Vectors or Lists is  Container  Let's say, we want to create a templated version of our Node and List.  IntNode  becomes:  template typename T \nstruct Node {\n   T val;\n   Node T  * next;\n};  and  IntLinkedList  becomes:  template typename T \nclass LinkedList {\n    public:\n        void push_front(T val);\n        // ...\n    private:\n        Node T  * head;\n};  To create a  LinkedList  of doubles, we declare the list as so:  LinkedList double  list;  In order to template functions and method, we do something similar.  For example, if we want to define the templated LinkedList's push_front  method:  template typename T \nLinkedList T ::push_front(T val) {\n    Node * new_node = new Node T ();\n    new_node -  val = val;\n\n    Node * old_head = this -  head;\n    new_node -  next = old_head;\n    this -  head = new_node;\n}  For more info on templates check out  this FAQ !", 
            "title": "Introducing templates!"
        }, 
        {
            "location": "/lab_week_01/#exercises", 
            "text": "Implement a vector class template. You should have an implementation of IntVector from CS12 that makes this much easier!   Pro-Tip: before implementing the class as a class template,  typedef  the type  T  as an integer and replace type with  T  as needed. \ne.g.  typedef int T; // give the int an alias which is T\nT my_int = 42;  This give you much nicer error messages and makes it easier to debug.  Example Usage, should implement at least the following methods:  MyVector string  vec;\nvec.push_back( CS14 );\nvec.push_back( World );\nvec.insert( Hello , 0); \ncout   vec.front()   endl; //  Hello \ncout   vec.back()   endl; //  World \nvec.pop_back();\ncout   vec.back()   endl; //  CS14 \nvec.pop_back();\ncout   vec.back()   endl; //  Hello \n\nMyVector int  another_vec;\nanother_vec.push_back(42);", 
            "title": "Exercises"
        }, 
        {
            "location": "/lab_week_01/#stretch-goal-exercise", 
            "text": "Rewrite your IntList as a class template!", 
            "title": "Stretch-goal exercise:"
        }, 
        {
            "location": "/lab_week_02/", 
            "text": "Lab 2: The Standard Template Library\n\n\nLike templates, you've already been using a small portion of the Standard Template Library.\n\n\nNamely, you're already well-acquainted with the contiguous container \nstd::vector\n and maybe even \nstd::list\n.\n\n\nThe Standard Template Library, or the \nSTL\n for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.\n\n\nSome of these algorithms range from simple algorithms such\nas \nstd::swap\n to the more complex \nstd::sort\n.\n\n\nThe motivation for learning and mastering the STL is to write \ncode that is clear and concise\n.\n\n\nIterators\n\n\nProbably the most important and inescapable concept in the\nSTL is the types we call iterators.\n\n\nIterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).\n\n\nThe easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).\n\n\n\"Enough talk, show me the code!\"\n Here's how you can iterate through a vector using iterators!\n\n\nvector\nint\n vec {1, 2, 3};\nvector\nint\n::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout \n *vec_iterator \n ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs \n1 2 3 \n\n\n\n\n\nNote the \nvec.begin()\n and \nvec.end()\n calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type \nvector\nint\n::iterator\n.\n\n\nvec.begin()\n returns an iterator to beginning of \nvec\n. However, \nvec.end()\n returns an iterator to the element \none past\n the last element.\n\n\nThis is pictured below (image from en.cppreference.com)\n\n\n\nA lot of algorithms in the STL, including \nstd::sort\n\nexpect iterators as arguments. \n(and usually specific types of iterators)\n\n\nOne of the function prototypes for \nstd::sort\n looks\nsomething like this:\n\n\ntemplate\ntypename RandomIt\n\nvoid sort(Iterator first, Iterator last);\n\n\n\n\nAs long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).\n\n\n#include \niostream\n\n#include \nvector\n\n#include \nalgorithm\n\nusing namespace std;\nint main() {\n    vector\nint\n vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout \n *vec_iter \n ' ';\n    }\n}\n\n\n\n\n`\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nThat's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!\n\n\nFunction Objects\n\n\nBack in CS12, you learned that you can \noverload\n\nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the\n\n+\n operator may look like this (assume the \ngcd\n function is defined):\n\n\nbool operator+(const Rational \n other) {\n    int new_denom = gcd(this -\n denom, other.denom);\n    int this_multipler = new_denom/(this -\n denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -\n numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}\n\n\n\n\nYou can also overload the function call operator by\ndefining a function with the function name \noperator()\n.\n\n\ne.g.\n\n\n#include \niostream\n\nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout \n count.get_count() \n endl;\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nOverloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include \nstd::sort\n\nand \nstd::copy_if\n. The most common types of\nfunction objects that these algorithms accept as input are\n\ncomparison function objects\n which return\ntrue if the first argument is \nconsidered\n less than the second and\na unary predicate which returns true if it satisfies some condition.\n\n\n#include \niostream\n\n#include \nalgorithm\n\n#include \nvector\n\n#include \nlist\n\nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int \n a, const int \n b ) const {\n            return a \n b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int \n x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector\nint\n from_vector {1, 2, 3, 4};\n    list\nint\n to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout \n elem \n ' ';\n    }\n    cout \n endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout \n elem \n ' ';\n    }\n}\n\n\n\n\nTry it yourself - before compiling guess what the above program outputs.\n\n\nExercise 1\n\n\nImplement your own STL-like reverse function, the reverse function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid my_reverse(BidirectionalIter first, BidirectionalIter last)\n\n\n\n\nThe function should reverse a portion of a container given two Bidirectional iterators (iterators you can move forward and backward).\nThe elements within the range [first, last) are reversed.\n\n\nExercise 2\n\n\nImplement rotate as an STL-like function. The rotate function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid my_rotate(BidirectionalIter first, BidirectionalIter n_first,\n               BidirectionalIter last)\n\n\n\n\nThe function should rotate the container given three Bidirectional\niterators: first, n_first and last. The rotate should make n_first\nthe first element in the container and n_first-1 the last element\nin the container. The new order should be [n_first, ..., last,  first, ... n_first-1]\n\n\nSuper Hint: The reverse function you just implement should really\ncome in handy!\n\n\nStretch-goal Exercise\n\n\nImplement mergesort as an STL-like function. The mergesort function\nwill have the following prototype:\n\n\ntemplate \ntypename BidirectionalIter\n\nvoid mergesort(BidirectionalIter first, BidirectionalIter last)\n\n\n\n\nGiven two Bidirectional Iterators, sort the container's elements\nwithin the range [first, last).\n\n\nUltra-hint: \nstd::inplace_merge\n and \nstd::distance\n are lifesavers here!\n\n\nCool References\n\n\nStandard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Lab Week 2"
        }, 
        {
            "location": "/lab_week_02/#lab-2-the-standard-template-library", 
            "text": "Like templates, you've already been using a small portion of the Standard Template Library.  Namely, you're already well-acquainted with the contiguous container  std::vector  and maybe even  std::list .  The Standard Template Library, or the  STL  for short, is\na library that provides many reusable (or generic) algorithms and data structures that programmers would otherwise have to reimplement themselves.  Some of these algorithms range from simple algorithms such\nas  std::swap  to the more complex  std::sort .  The motivation for learning and mastering the STL is to write  code that is clear and concise .", 
            "title": "Lab 2: The Standard Template Library"
        }, 
        {
            "location": "/lab_week_02/#iterators", 
            "text": "Probably the most important and inescapable concept in the\nSTL is the types we call iterators.  Iterators are used to generalize the iterator over an STL container (or your own containers that implement iterators).  The easiest way to think about iterators is to think of them as fancy pointers (again, this conceptual model works for 80% of use cases - it's not entirely correct).  \"Enough talk, show me the code!\"  Here's how you can iterate through a vector using iterators!  vector int  vec {1, 2, 3};\nvector int ::iterator vec_iterator = vec.begin();\n\n// go through the vector until we hit vec.end()\nwhile(vec_iterator != vec.end()) {\n    cout   *vec_iterator   ' ';\n    vec_iterator++; //move the iterator up one\n}\n// Outputs  1 2 3    Note the  vec.begin()  and  vec.end()  calls in the above\ncode block. Both of these return an iterator to different\npositions in the vector container. Both also return an\niterator of type  vector int ::iterator .  vec.begin()  returns an iterator to beginning of  vec . However,  vec.end()  returns an iterator to the element  one past  the last element.  This is pictured below (image from en.cppreference.com)  A lot of algorithms in the STL, including  std::sort \nexpect iterators as arguments.  (and usually specific types of iterators)  One of the function prototypes for  std::sort  looks\nsomething like this:  template typename RandomIt \nvoid sort(Iterator first, Iterator last);  As long as we provide the sort function valid iterators, it will sort\nthe elements within the range [first, last).  #include  iostream \n#include  vector \n#include  algorithm \nusing namespace std;\nint main() {\n    vector int  vec {42, 8, 3};\n\n    // sort all of the elements in vec in ascending order\n    sort(vec.begin(), vec.end());\n\n    /*\n        We can use auto to omit the type\n        on the left-hand side in C++11!\n\n        Also, this is a way to iterate through a\n        vector using iterators with a for-loop!\n    */\n    for(auto vec_iter = vec.begin(); vec_iter != vec.end(); vec_iter++){\n        cout   *vec_iter   ' ';\n    }\n}  ` Try it yourself - before compiling guess what the above program outputs.  That's cool and all, but what if we want to sort the\ncontainer in descending order: function objects come\nto the rescue!", 
            "title": "Iterators"
        }, 
        {
            "location": "/lab_week_02/#function-objects", 
            "text": "Back in CS12, you learned that you can  overload \nspecial operators while defining classes. The prototype\nof a method of a rational number class which overloads the +  operator may look like this (assume the  gcd  function is defined):  bool operator+(const Rational   other) {\n    int new_denom = gcd(this -  denom, other.denom);\n    int this_multipler = new_denom/(this -  denom);\n    int other_multipler = new_denom/(other.denom);\n    int new_numer = this_multipler  * this -  numer +\n                    other_multipler * other.numer;\n    return Rational(new_numer, new_denom);\n}  You can also overload the function call operator by\ndefining a function with the function name  operator() .  e.g.  #include  iostream \nusing namespace std;\n\nclass Counter {\n    public:\n        Counter() :count(0) {}\n        Counter(int count) : count(count) {}\n        void operator() () {\n            ++count;\n        }\n        int get_count() {\n            return count;\n        }\n    private:\n        int count;\n};\nint main() {\n    Counter count;\n    count();\n    count();\n    cout   count.get_count()   endl;\n}  Try it yourself - before compiling guess what the above program outputs.  Overloading the function call operator automatically makes the\nclass a \"function object\". This becomes useful in a number of\nSTL algorithms. Some of the algorithms include  std::sort \nand  std::copy_if . The most common types of\nfunction objects that these algorithms accept as input are comparison function objects  which return\ntrue if the first argument is  considered  less than the second and\na unary predicate which returns true if it satisfies some condition.  #include  iostream \n#include  algorithm \n#include  vector \n#include  list \nusing namespace std;\n\nclass SortGreater {\n    public:\n        bool operator() (const int   a, const int   b ) const {\n            return a   b;\n        }\n};\n\nclass IsEven {\n    public:\n        bool operator() (const int   x) const {\n            return x % 2 == 0;\n        }\n};\n\nint main() {\n    vector int  from_vector {1, 2, 3, 4};\n    list int  to_list(2);\n\n    sort(from_vector.begin(), from_vector.end(), SortGreater());\n    for (int elem : from_vector) {\n        cout   elem   ' ';\n    }\n    cout   endl;\n\n    copy_if(from_vector.begin(), from_vector.end(), to_list.begin(), IsEven());\n\n    for (int elem : to_list) {\n        cout   elem   ' ';\n    }\n}  Try it yourself - before compiling guess what the above program outputs.", 
            "title": "Function Objects"
        }, 
        {
            "location": "/lab_week_02/#exercise-1", 
            "text": "Implement your own STL-like reverse function, the reverse function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid my_reverse(BidirectionalIter first, BidirectionalIter last)  The function should reverse a portion of a container given two Bidirectional iterators (iterators you can move forward and backward).\nThe elements within the range [first, last) are reversed.", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_02/#exercise-2", 
            "text": "Implement rotate as an STL-like function. The rotate function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid my_rotate(BidirectionalIter first, BidirectionalIter n_first,\n               BidirectionalIter last)  The function should rotate the container given three Bidirectional\niterators: first, n_first and last. The rotate should make n_first\nthe first element in the container and n_first-1 the last element\nin the container. The new order should be [n_first, ..., last,  first, ... n_first-1]  Super Hint: The reverse function you just implement should really\ncome in handy!", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_02/#stretch-goal-exercise", 
            "text": "Implement mergesort as an STL-like function. The mergesort function\nwill have the following prototype:  template  typename BidirectionalIter \nvoid mergesort(BidirectionalIter first, BidirectionalIter last)  Given two Bidirectional Iterators, sort the container's elements\nwithin the range [first, last).  Ultra-hint:  std::inplace_merge  and  std::distance  are lifesavers here!", 
            "title": "Stretch-goal Exercise"
        }, 
        {
            "location": "/lab_week_02/#cool-references", 
            "text": "Standard Template Library Video Series by Stephan T. Lavaej at Microsoft", 
            "title": "Cool References"
        }, 
        {
            "location": "/lab_week_03/", 
            "text": "Lab 3: Stacks and Queues\n\n\nStacks\n\n\nStacks are LIFO (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.\n\n\nHere's a small demo of how stacks work:\n\n\n#include \niostream\n\n#include \nstack\n\n\nusing namespace std;\n\nint main() {\n  stack\nint\n s;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout \n \nPopping (\n \n s.top() \n \n)\n \n endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout \n \nstack is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nTry running that and see what is output.\nGo ahead. I'll wait.\n\n\nWere you surprised by the output?\n\n\nQueues\n\n\nQueues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.\n\n\nHere's a small demo of how queues work:\n\n\n#include \niostream\n\n#include \nqueue\n\n\nusing namespace std;\n\nint main() {\n  queue\nint\n q;\n  for(unsigned i = 0; i \n 6; ++i) {\n    cout \n \nPushing i (\n \n i \n \n)\n \n endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout \n \nPopping (\n \n q.front() \n \n)\n \n endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout \n \nqueue is empty\n \n endl;\n\n  return 0;\n}\n\n\n\n\nRun it!!\n\n\nExercise 1\n\n\nImplement your own \nstack\n and \nqueue\n!\n\n\nThe \nstack\n should have the following public members:\n\n\ntemplate \ntypename T\n\nclass myStack {\n  public:\n    void push(T);       // adds an element to the top of the stack\n    T top() const;      // gets the element at the top of the stack\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n};\n\n\n\n\nThe \nqueue\n should have the following public members:\n\n\ntemplate \ntypename T\n\nclass myQueue {\n  public:\n    void push(T);       // adds an element to the back of the queue\n    T front() const;    // gets the element at the front of the queue\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n};\n\n\n\n\nImportant\n: Use a \ndeque\n, \nlist\n, or \nvector\n to do all of the heavy lifting for you.\nIn other words, if you're using arrays and nodes to solve this, you're doing too much work.\n\n\nExercise 2\n\n\nYou're all probably able to recite the recursive factorial function in your sleep:\n\n\nunsigned long fact(unsigned long n) {\n  if (n \n 2) return 1;\n  return n * fact(n - 1);\n}\n\n\n\n\nWrite a non-recursive factorial function that takes advantage of \nstack\n similarly to how recursion works.\n\n\nStretch-goal Exercise 1\n\n\nMake a \nqueue\n using two stacks!\n\n\nStretch-goal Exercise 2\n\n\nMake a new class \nminStack\n that has the same efficiency as a \nstack\n for \npush\n and \npop\n, as well as constant lookup for the minimum element in the stack.\n\n\nIn other words, I should be able to do this all in constant time:\n\n\nint main() {\n  minStack\nint\n ms;\n  ms.push(3);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(1);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(4);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(1);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(5);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(9);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(2);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n  ms.push(6);\n  cout \n \nmin: \n \n ms.min() \n \n(pushed \n \n ms.top() \n \n)\n \n endl;\n\n  while (!ms.empty()) {\n    int temp = ms.top();\n    ms.pop();\n    cout \n \nmin: \n \n ms.min() \n \n(popped \n \n temp \n \n)\n \n endl;\n  }\n\n  return 0;\n}\n\n\n\n\nPrototype:\n\n\ntemplate \ntypename T\n\nclass minStack() {\n  public:\n    void push(T);       // adds an element to the top of the stack\n    T top() const;      // gets the element at the top of the stack\n    T min() const;      // gets minimum element\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n}\n\n\n\n\n(Hint: you can use whatever internal data type you'd like)\n\n\n(\nHint:\n use two stacks)", 
            "title": "Lab Week 3"
        }, 
        {
            "location": "/lab_week_03/#lab-3-stacks-and-queues", 
            "text": "", 
            "title": "Lab 3: Stacks and Queues"
        }, 
        {
            "location": "/lab_week_03/#stacks", 
            "text": "Stacks are LIFO (last in, first out) data structures.\nYou've already encountered stacks before.\nRecursion takes advantage of the function call stack.  Here's a small demo of how stacks work:  #include  iostream \n#include  stack \n\nusing namespace std;\n\nint main() {\n  stack int  s;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    s.push(i);\n  }\n\n  while (!s.empty()) {\n    cout    Popping (    s.top()    )    endl;\n    s.pop();\n  }\n\n  if (s.empty()) cout    stack is empty    endl;\n\n  return 0;\n}  Try running that and see what is output.\nGo ahead. I'll wait.  Were you surprised by the output?", 
            "title": "Stacks"
        }, 
        {
            "location": "/lab_week_03/#queues", 
            "text": "Queues are FIFO (first in, first out) data structures.\nThey're structured similarly to checkout lines at the grocery store;\nWhoever gets in line first gets serviced first.  Here's a small demo of how queues work:  #include  iostream \n#include  queue \n\nusing namespace std;\n\nint main() {\n  queue int  q;\n  for(unsigned i = 0; i   6; ++i) {\n    cout    Pushing i (    i    )    endl;\n    q.push(i);\n  }\n\n  while (!q.empty()) {\n    cout    Popping (    q.front()    )    endl;\n    q.pop();\n  }\n\n  if (q.empty()) cout    queue is empty    endl;\n\n  return 0;\n}  Run it!!", 
            "title": "Queues"
        }, 
        {
            "location": "/lab_week_03/#exercise-1", 
            "text": "Implement your own  stack  and  queue !  The  stack  should have the following public members:  template  typename T \nclass myStack {\n  public:\n    void push(T);       // adds an element to the top of the stack\n    T top() const;      // gets the element at the top of the stack\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n};  The  queue  should have the following public members:  template  typename T \nclass myQueue {\n  public:\n    void push(T);       // adds an element to the back of the queue\n    T front() const;    // gets the element at the front of the queue\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n};  Important : Use a  deque ,  list , or  vector  to do all of the heavy lifting for you.\nIn other words, if you're using arrays and nodes to solve this, you're doing too much work.", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_03/#exercise-2", 
            "text": "You're all probably able to recite the recursive factorial function in your sleep:  unsigned long fact(unsigned long n) {\n  if (n   2) return 1;\n  return n * fact(n - 1);\n}  Write a non-recursive factorial function that takes advantage of  stack  similarly to how recursion works.", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_03/#stretch-goal-exercise-1", 
            "text": "Make a  queue  using two stacks!", 
            "title": "Stretch-goal Exercise 1"
        }, 
        {
            "location": "/lab_week_03/#stretch-goal-exercise-2", 
            "text": "Make a new class  minStack  that has the same efficiency as a  stack  for  push  and  pop , as well as constant lookup for the minimum element in the stack.  In other words, I should be able to do this all in constant time:  int main() {\n  minStack int  ms;\n  ms.push(3);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(1);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(4);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(1);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(5);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(9);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(2);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n  ms.push(6);\n  cout    min:     ms.min()    (pushed     ms.top()    )    endl;\n\n  while (!ms.empty()) {\n    int temp = ms.top();\n    ms.pop();\n    cout    min:     ms.min()    (popped     temp    )    endl;\n  }\n\n  return 0;\n}  Prototype:  template  typename T \nclass minStack() {\n  public:\n    void push(T);       // adds an element to the top of the stack\n    T top() const;      // gets the element at the top of the stack\n    T min() const;      // gets minimum element\n    bool pop();         // returns false if failed\n    bool empty() const; // returned true if empty\n}  (Hint: you can use whatever internal data type you'd like)  ( Hint:  use two stacks)", 
            "title": "Stretch-goal Exercise 2"
        }, 
        {
            "location": "/lab_week_04/", 
            "text": "Lab 4: Binary Search Trees (BST)\n\n\nWhat's a tree?\n\n\nTrees are often easier to deal with recursively (or if you're a mathematician, 'inductively').\nThus, to define a tree recursively, we can say that:\n\n\n\n\nA Tree is a system of nodes\n\n\nA node consists of a value and pointers to its children\n\n\n\n\n\n\nEvery node has a unique parent\n\n\nNo node has more than one parent\n\n\n\n\n\n\nThe \nRoot\n of a tree has no parent\n\n\nA Node can have any number of children (including 0)\n\n\n\n\nWhen we put all of these things together, we end up with something looking like:\n\n\n\n\nWhere the numbers in the nodes represent the value at that node, and the arrows represent pointers to children nodes.\n\n\nWhat's a BST?\n\n\nA Binary Search Tree is exactly like any other tree, except every node has \nexactly\n two children (if there is no child, the node will be a null pointer).\nFurtermore (and more importantly), every child to the left of a node will be less than the node, while every child to the right will be greater.\n\n\nYou'll notice that the picture above is \nNOT\n a BST. Even though each node has two children (we can pretend that there are invisible null children), if we go to the left child of our root, we find a value that is \ngreater\n, breaking our definition.\n\n\nThis\n would be a valid Binary Search Tree:\n\n\n\n\nNotice how \nevery\n number to the left of any node (take 8 for example), is less than the node itself (1, 3, 4, 5, 7). Since this is the case, where will the smallest node be? What about the largest?\n\n\nPut it into practice!\n\n\nWe have created a \nsimple implementation of a BST\n for you to use. The class comes with the member functions \nvoid push(T val)\n to add values to the tree, and \nvoid print()\n to print a rough representation of the tree.\n\n\nNOTE:\n\n\nIt is often almost always easier to write Tree functions recursively (as you'll see the push function has been written). However, it \nis\n possible to do all of the following exercises without recursion--you'll just need to be iterating over a stack you're constantly pushing and popping to (as you'll see the print function is doing).\n\n\nExercise 1\n\n\nAdd \nmin\n and \nmax\n funcitons to the \nTree\n class to return the minimum and maxiumum values stored.\n\n\n(If there are no values in the tree, return the class default, \nT()\n)\n\n\nExercise 2\n\n\nAdd a \nfind\n function to the \nTree\n class that will find a value in the tree and return a Node pointer. If the value is not found, return the null pointer.\n\n\nExercise 3\n\n\nAdd a \ntotal\n function to the \nTree\n class that will return the total of all of the items in the tree (\nx1 + x2 + ... + xn\n).\n\n\nExercise 4\n\n\nAdd \nprint_ascending\n and \nprint_descending\n functions to the \nTree\n class that will print all of the values in the tree in ascending and descending order on one line seperated by spaces.\n\n\n(Notice how it didn't matter what order you 'visited' the nodes to find the total. Make sure you have your order correct here!)\n\n\nExercise 5\n\n\nYou may notice that 3 very important functions are still missing from our tree. Can you guess what they are? (\nhint:\n \nwhat is the rule of 3?\n)\n\n\nSince we are using heap memory like a linked list, we need a \nCopy Constructor\n, \nOverloaded Assignment Operator\n and \nDestructor\n!\n\n\nYour stretch goal will be to make the Copy-ctor and Assignment-op, but for Exercise 5, implement a Destructor for the Tree class.\n\n\n(What order will you visit the nodes to delete them?)", 
            "title": "Lab Week 4"
        }, 
        {
            "location": "/lab_week_04/#lab-4-binary-search-trees-bst", 
            "text": "", 
            "title": "Lab 4: Binary Search Trees (BST)"
        }, 
        {
            "location": "/lab_week_04/#whats-a-tree", 
            "text": "Trees are often easier to deal with recursively (or if you're a mathematician, 'inductively').\nThus, to define a tree recursively, we can say that:   A Tree is a system of nodes  A node consists of a value and pointers to its children    Every node has a unique parent  No node has more than one parent    The  Root  of a tree has no parent  A Node can have any number of children (including 0)   When we put all of these things together, we end up with something looking like:   Where the numbers in the nodes represent the value at that node, and the arrows represent pointers to children nodes.", 
            "title": "What's a tree?"
        }, 
        {
            "location": "/lab_week_04/#whats-a-bst", 
            "text": "A Binary Search Tree is exactly like any other tree, except every node has  exactly  two children (if there is no child, the node will be a null pointer).\nFurtermore (and more importantly), every child to the left of a node will be less than the node, while every child to the right will be greater.  You'll notice that the picture above is  NOT  a BST. Even though each node has two children (we can pretend that there are invisible null children), if we go to the left child of our root, we find a value that is  greater , breaking our definition.  This  would be a valid Binary Search Tree:   Notice how  every  number to the left of any node (take 8 for example), is less than the node itself (1, 3, 4, 5, 7). Since this is the case, where will the smallest node be? What about the largest?", 
            "title": "What's a BST?"
        }, 
        {
            "location": "/lab_week_04/#put-it-into-practice", 
            "text": "We have created a  simple implementation of a BST  for you to use. The class comes with the member functions  void push(T val)  to add values to the tree, and  void print()  to print a rough representation of the tree.  NOTE:  It is often almost always easier to write Tree functions recursively (as you'll see the push function has been written). However, it  is  possible to do all of the following exercises without recursion--you'll just need to be iterating over a stack you're constantly pushing and popping to (as you'll see the print function is doing).", 
            "title": "Put it into practice!"
        }, 
        {
            "location": "/lab_week_04/#exercise-1", 
            "text": "Add  min  and  max  funcitons to the  Tree  class to return the minimum and maxiumum values stored.  (If there are no values in the tree, return the class default,  T() )", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_04/#exercise-2", 
            "text": "Add a  find  function to the  Tree  class that will find a value in the tree and return a Node pointer. If the value is not found, return the null pointer.", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_04/#exercise-3", 
            "text": "Add a  total  function to the  Tree  class that will return the total of all of the items in the tree ( x1 + x2 + ... + xn ).", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/lab_week_04/#exercise-4", 
            "text": "Add  print_ascending  and  print_descending  functions to the  Tree  class that will print all of the values in the tree in ascending and descending order on one line seperated by spaces.  (Notice how it didn't matter what order you 'visited' the nodes to find the total. Make sure you have your order correct here!)", 
            "title": "Exercise 4"
        }, 
        {
            "location": "/lab_week_04/#exercise-5", 
            "text": "You may notice that 3 very important functions are still missing from our tree. Can you guess what they are? ( hint:   what is the rule of 3? )  Since we are using heap memory like a linked list, we need a  Copy Constructor ,  Overloaded Assignment Operator  and  Destructor !  Your stretch goal will be to make the Copy-ctor and Assignment-op, but for Exercise 5, implement a Destructor for the Tree class.  (What order will you visit the nodes to delete them?)", 
            "title": "Exercise 5"
        }, 
        {
            "location": "/lab_week_05/", 
            "text": "Lab Week 5: Sets and Maps\n\n\nExercise 1\n\n\nWrite a function called \nfreq_map\n which takes in a vector\nof strings and returns a stringfrequency map, a map which\nmaps strings to the number of times it appears in the\nvector.\n\n\nUse the following function prototype:\n\n\nstd::map\nstd::string, unsigned int\n freq_map(std::vector\nstd::string\n words) \n\n\n\n\nUse the following text file to test your function, read the words\nfrom the file and put them into a super big vector!\n\nhttp://termbin.com/1x6w\n\n\nExercise 2\n\n\nWrite a function that returns a vector of the top \nn\n most frequent strings in the frequency map.\n\n\nUse the following header!\n\n\nstd::vector\nstd::string\n \ntop_n(std::map\nstd::string, unsigned int\n freq_map, unsigned int n = 5)\n\n\n\n\nStretch-Goal Exercise 1\n\n\nWrite a class called \nAnagramChecker\n which \nkeeps track of strings and is able to tell\nif any other string is an anagram in in its\ndata structure.\n\n\nUsage example:\n\n\n#include \nanagramchecker.h\n\n#include \niostream\n\n#include \nstring\n\nusing namespace std;\n\nvoid printIfAnagram(const AnagramChecker \n a, string s) {\n    if(a.check(s)) {\n        cout \n s \n \n is an anagram of one of the words in the checker\n \n endl;\n    } else {\n        cout \n s \n \n is not an anagram of one of the words in the checker\n \n endl;\n    }\n}\n\nint main() {\n    AnagramChecker a;\n    a.add(\nhello\n);\n    a.add(\nbye\n);\n\n    printIfAnagram(a, \napple\n);\n    printIfAnagram(a, \nolleh\n);\n}\n\n\n\n\nThe above program should print out \n\n\napple is not an anagram of one of the words in the checker\nolleh is an anagram of one of the words in the checker\n\n\n\n\n\nRequirements, the data structure must meet the following\nspace and time complexity requirements:\n\n\nWhere \nn\n is the number of strings stored by the data structure.\n\n\nData Structure: O(n) space\n\nOperations:\n    add(string)\n        Time: O(log n)\n\n    check(string)\n        Time: O(log n)\n\n\n\n\nExtra Bits: Stretch-Goal Exercise 1\n\n\nImprove SG Exercise 1 so that the data structure guarantees\nthe following time complexities: \n\n\nData Structure: O(n) space\n\nOperations:\n    add(string)\n        Time: O(1) amortized\n\n    check(string)\n        Time: O(1) amortized", 
            "title": "Lab Week 5"
        }, 
        {
            "location": "/lab_week_05/#lab-week-5-sets-and-maps", 
            "text": "", 
            "title": "Lab Week 5: Sets and Maps"
        }, 
        {
            "location": "/lab_week_05/#exercise-1", 
            "text": "Write a function called  freq_map  which takes in a vector\nof strings and returns a stringfrequency map, a map which\nmaps strings to the number of times it appears in the\nvector.  Use the following function prototype:  std::map std::string, unsigned int  freq_map(std::vector std::string  words)   Use the following text file to test your function, read the words\nfrom the file and put them into a super big vector! http://termbin.com/1x6w", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_05/#exercise-2", 
            "text": "Write a function that returns a vector of the top  n  most frequent strings in the frequency map.  Use the following header!  std::vector std::string  \ntop_n(std::map std::string, unsigned int  freq_map, unsigned int n = 5)", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_05/#stretch-goal-exercise-1", 
            "text": "Write a class called  AnagramChecker  which \nkeeps track of strings and is able to tell\nif any other string is an anagram in in its\ndata structure.  Usage example:  #include  anagramchecker.h \n#include  iostream \n#include  string \nusing namespace std;\n\nvoid printIfAnagram(const AnagramChecker   a, string s) {\n    if(a.check(s)) {\n        cout   s     is an anagram of one of the words in the checker    endl;\n    } else {\n        cout   s     is not an anagram of one of the words in the checker    endl;\n    }\n}\n\nint main() {\n    AnagramChecker a;\n    a.add( hello );\n    a.add( bye );\n\n    printIfAnagram(a,  apple );\n    printIfAnagram(a,  olleh );\n}  The above program should print out   apple is not an anagram of one of the words in the checker\nolleh is an anagram of one of the words in the checker  Requirements, the data structure must meet the following\nspace and time complexity requirements:  Where  n  is the number of strings stored by the data structure.  Data Structure: O(n) space\n\nOperations:\n    add(string)\n        Time: O(log n)\n\n    check(string)\n        Time: O(log n)", 
            "title": "Stretch-Goal Exercise 1"
        }, 
        {
            "location": "/lab_week_05/#extra-bits-stretch-goal-exercise-1", 
            "text": "Improve SG Exercise 1 so that the data structure guarantees\nthe following time complexities:   Data Structure: O(n) space\n\nOperations:\n    add(string)\n        Time: O(1) amortized\n\n    check(string)\n        Time: O(1) amortized", 
            "title": "Extra Bits: Stretch-Goal Exercise 1"
        }, 
        {
            "location": "/lab_week_06/", 
            "text": "Lab Week 6: Hash Tables\n\n\nExercise 1\n\n\n(Kinda) heap sort! Use \nstd::priority_queue\n to\nsort a vector in ascending order. \nstd::greater\n\nmay prove useful. \n\n\nHint2: Check out the Example at [cppreference Queue] - the top, pop and push operations can make this possible!(http://en.cppreference.com/w/cpp/container/priority_queue)\n\n\nvoid pq_sort(std::vector\nint\n \n v)\n\n\n\n\nExercise 2\n\n\nWrite a class called \nUnorderedSet\n with the following\npublic methods:\n\n\nNote: first we will test with \nstd::string\n instead\nof \nT\n. So in your code we should we should \ndeclare the following typedef: \ntypedef std::string T\n.\n\n\nint count(const T \n elem)\nvoid remove(const T \n elem) \nvoid insert(const T \n elem)\n\n\n\n\nYour implementation of UnorderedSet uses a \nhash table with 6159 buckets (\nsomewhat \narbitrary prime\n). For this exercise you will handle collisions \nusing the seperate chaining method, where each\nthe hash function mod the table size gives you a bucket\nand each bucket is a \nstd::list\n of keys.\n\n\nFor testing purposes, we will use the following\nnaive hash function:\n\n\nunsigned int str_hash(std::string s){\n    /*\n     * This hash simply adds up\n     * the ascii values of each character in\n     * the string.\n    */\n    unsigned int hash_val = 0;\n    unsigned int ascii_val = 0;\n    for (char c : s) {\n        ascii_val = static_cast\nunsigned int\n(c);\n        hash_val += ascii_val;\n    }\n    return hash_val;\n}\n\n\n\n\nUse the following print method to test your class! (assumes \n_buckets\n is the\nname of the array of buckets)\n\n\nvoid print() {\n   unsigned int used_buckets = 0;\n   unsigned int num_elems = 0;\n   for(unsigned int i = 0; i \n NUM_BUCKETS; ++i) {\n        const auto \n bucket = _buckets[i];\n        if(!bucket.empty()) {\n            ++used_buckets;\n            std::cout \n \nbucket #\n \n  i \n ':';\n            for(const auto \n elem: bucket) {\n                std::cout \n elem \n ',';\n                ++num_elems;\n            }\n            std::cout \n std::endl \n std::endl;\n        }\n   }\n   std::cout \n \nNumber of buckets used: \n \n used_buckets\n       \n '/'  \n NUM_BUCKETS  \n std::endl;\n   std::cout \n \nNumber of total elements: \n \n num_elems \n std::endl;\n}\n\n\n\n\n\n\nStretch-Goal Exercise\n\n\nExtend your \nUnorderedSet\n class to a \nUnorderedMap\n class! Use the same collision resolution method.\n\n\nImplement the following class methods:\n\n\nint count (const Key \n k)\nValue \n operator[](const Key * k) \nvoid remove(const Key \n k)", 
            "title": "Lab Week 6"
        }, 
        {
            "location": "/lab_week_06/#lab-week-6-hash-tables", 
            "text": "", 
            "title": "Lab Week 6: Hash Tables"
        }, 
        {
            "location": "/lab_week_06/#exercise-1", 
            "text": "(Kinda) heap sort! Use  std::priority_queue  to\nsort a vector in ascending order.  std::greater \nmay prove useful.   Hint2: Check out the Example at [cppreference Queue] - the top, pop and push operations can make this possible!(http://en.cppreference.com/w/cpp/container/priority_queue)  void pq_sort(std::vector int    v)", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_06/#exercise-2", 
            "text": "Write a class called  UnorderedSet  with the following\npublic methods:  Note: first we will test with  std::string  instead\nof  T . So in your code we should we should \ndeclare the following typedef:  typedef std::string T .  int count(const T   elem)\nvoid remove(const T   elem) \nvoid insert(const T   elem)  Your implementation of UnorderedSet uses a \nhash table with 6159 buckets ( somewhat \narbitrary prime ). For this exercise you will handle collisions \nusing the seperate chaining method, where each\nthe hash function mod the table size gives you a bucket\nand each bucket is a  std::list  of keys.  For testing purposes, we will use the following\nnaive hash function:  unsigned int str_hash(std::string s){\n    /*\n     * This hash simply adds up\n     * the ascii values of each character in\n     * the string.\n    */\n    unsigned int hash_val = 0;\n    unsigned int ascii_val = 0;\n    for (char c : s) {\n        ascii_val = static_cast unsigned int (c);\n        hash_val += ascii_val;\n    }\n    return hash_val;\n}  Use the following print method to test your class! (assumes  _buckets  is the\nname of the array of buckets)  void print() {\n   unsigned int used_buckets = 0;\n   unsigned int num_elems = 0;\n   for(unsigned int i = 0; i   NUM_BUCKETS; ++i) {\n        const auto   bucket = _buckets[i];\n        if(!bucket.empty()) {\n            ++used_buckets;\n            std::cout    bucket #     i   ':';\n            for(const auto   elem: bucket) {\n                std::cout   elem   ',';\n                ++num_elems;\n            }\n            std::cout   std::endl   std::endl;\n        }\n   }\n   std::cout    Number of buckets used:     used_buckets\n         '/'    NUM_BUCKETS    std::endl;\n   std::cout    Number of total elements:     num_elems   std::endl;\n}", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_06/#stretch-goal-exercise", 
            "text": "Extend your  UnorderedSet  class to a  UnorderedMap  class! Use the same collision resolution method.  Implement the following class methods:  int count (const Key   k)\nValue   operator[](const Key * k) \nvoid remove(const Key   k)", 
            "title": "Stretch-Goal Exercise"
        }, 
        {
            "location": "/lab_week_07/", 
            "text": "Lab Week 7: Binary Heaps\n\n\nBinary Heaps are binary trees similar to BSTs, but have different properties.\nThe two types of Binary Heaps you need to know about are MinHeaps and MaxHeaps.\nIn a MinHeap, the only rule (besides adhering to tree rules) is that children have a larger value than their parent.\nSimilarly, MaxHeaps maintain that all children are less than their parent.\n\n\nWhen inserting nodes into a Binary Heap, start by filling in values at the bottom of the tree from left to right.\nFor each insertion, heapify up to verify that the rules of the tree have not been broken.\nHeapify up is a simple procedure; for a MinHeap, check if the parent is larger than the current value.\nIf it is, swap them and repeat for the parent until there is no parent or the parent is less than or equal to it's child's value.\nThis occurs in logarithmic time.\n\n\nTo find the minimum value in a MinHeap, it takes constant time.\nWhere do you think the minimum value is located?\n\n\nTo remove the minimum, swap the root with the most recently inserted value at the bottom of the tree.\nThen, remove the swapped minimum value from the tree.\nNext, find the smallest of the root's two children.\nIf the smallest of those is smaller than the new root, swap with the root.\nRepeat this process on the swapped branch through to the bottom of the tree.\nThis takes logarithmic time.\n\n\nUse \nthis visualization\n of a MinHeap to help you with the exercise below.\n\n\nNote\n: use the following class prototype:\n\n\n#include \nvector\n\n#include \nalgorithm\n\n#include \nfunctional\n\n\ntemplate\ntypename T, typename Less=std::less\nT\n\nclass MinHeap {\n    public:\n        const T \n top();\n        void push(const T \n elem);\n        void pop();\n        bool empty();\n        void heapify(const std::vector\nT\n \n vec);\n    private:\n        std::vector\nT\n _heap;\n        Less _less;\n};\n\n\n\n\n\n\n\nExercise 1\n\n\nempty\n returns \ntrue\n or \nfalse\n depending on whether or not there are items in the \nheap\n\n\nImplement \nempty\n.\nComment out the other unimplemented functions to make sure you copied everything over correctly.\nRun a simple test to make sure it works.\n\n\nExercise 2\n\n\npush\n adds elements to the \nheap\n.\n\ntop\n gets the top element of the \nheap\n.\n\nheapify\n takes a vector of elements and adds them to the heap.\n\n\nImplement \npush\n, \ntop\n, and \nheapify\n.\nSee \nthis gist\n for some test test harnesses.\nFeel free to write your own as well.\nComment out the tests that use \npop\n.\n\n\nExercise 3\n\n\npop\n removes the top element of the \nheap\n.\n\n\nImplement \npop\n and run all the tests on your code.", 
            "title": "Lab Week 7"
        }, 
        {
            "location": "/lab_week_07/#lab-week-7-binary-heaps", 
            "text": "Binary Heaps are binary trees similar to BSTs, but have different properties.\nThe two types of Binary Heaps you need to know about are MinHeaps and MaxHeaps.\nIn a MinHeap, the only rule (besides adhering to tree rules) is that children have a larger value than their parent.\nSimilarly, MaxHeaps maintain that all children are less than their parent.  When inserting nodes into a Binary Heap, start by filling in values at the bottom of the tree from left to right.\nFor each insertion, heapify up to verify that the rules of the tree have not been broken.\nHeapify up is a simple procedure; for a MinHeap, check if the parent is larger than the current value.\nIf it is, swap them and repeat for the parent until there is no parent or the parent is less than or equal to it's child's value.\nThis occurs in logarithmic time.  To find the minimum value in a MinHeap, it takes constant time.\nWhere do you think the minimum value is located?  To remove the minimum, swap the root with the most recently inserted value at the bottom of the tree.\nThen, remove the swapped minimum value from the tree.\nNext, find the smallest of the root's two children.\nIf the smallest of those is smaller than the new root, swap with the root.\nRepeat this process on the swapped branch through to the bottom of the tree.\nThis takes logarithmic time.  Use  this visualization  of a MinHeap to help you with the exercise below.  Note : use the following class prototype:  #include  vector \n#include  algorithm \n#include  functional \n\ntemplate typename T, typename Less=std::less T \nclass MinHeap {\n    public:\n        const T   top();\n        void push(const T   elem);\n        void pop();\n        bool empty();\n        void heapify(const std::vector T    vec);\n    private:\n        std::vector T  _heap;\n        Less _less;\n};", 
            "title": "Lab Week 7: Binary Heaps"
        }, 
        {
            "location": "/lab_week_07/#exercise-1", 
            "text": "empty  returns  true  or  false  depending on whether or not there are items in the  heap  Implement  empty .\nComment out the other unimplemented functions to make sure you copied everything over correctly.\nRun a simple test to make sure it works.", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_07/#exercise-2", 
            "text": "push  adds elements to the  heap . top  gets the top element of the  heap . heapify  takes a vector of elements and adds them to the heap.  Implement  push ,  top , and  heapify .\nSee  this gist  for some test test harnesses.\nFeel free to write your own as well.\nComment out the tests that use  pop .", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_07/#exercise-3", 
            "text": "pop  removes the top element of the  heap .  Implement  pop  and run all the tests on your code.", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/lab_week_08/", 
            "text": "Lab Week 8: QuickSort\n\n\nToday you will be implementing Quicksort.\nFor a mediocre visualization on how Quicksort works, go \nhere\n.\n\n\nThe general algorithm for quicksort:\n\n\ndef Quicksort(L):\n    # lists of size 1 or less\n    # are sorted by definition\n    if (len(L) \n= 1):\n        return\n\n    # select pivot index using\n    # the list of elements\n    pivot = selectPivot(L)\n\n    # partition into two halves\n    # using the pivot value\n    partIdx = partition(L, pivot)\n\n    # recursively sort the left\n    # and right sublists\n    Quicksort(L[:partIdx])\n    Quicksort(L[partIdx:])\n\n\n\n\nDeclarations for lab today:\n\n\n#include \nutility\n\n#include \nalgorithm\n\n#include \nvector\n\n#include \nfunctional\n\n#include \niostream\n\n#include \niterator\n\n\n/*\n * takes three values and uses comp to put them in sorted order.\n * the median ends up at b.\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nvoid median_of_three(T \n a, T \n b, T \n c, Compare comp = Compare());\n\n/*\n * partitions v from first to last using mid as the pivot\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nint partition(std::vector\nT\n \n v, int first, int mid, int last, Compare comp = Compare());\n\n/*\n * same as other partition;\n * creates two vectors for the left and right, then puts all the elements (except for mid)\n * in the two. Then, they are put back in v so that v is partitioned, and returns the\n * index of the pivot value.\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nint naive_partition(std::vector\nT\n \n v, int first, int mid, int last, Compare comp = Compare());\n\n/*\n * uses the median of three pivot selection method, and the naive partition method\n * to implement quicksort\n *\n * has a base case of a list of size 1 or fewer\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nvoid naive_quicksort(std::vector\nT\n \n v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate\ntypename T\n\nvoid naive_quicksort(std::vector\nT\n \n v) {\n    naive_quicksort(v, 0, v.size());\n}\n\n/*\n * uses the median of three pivot selection method, and the faster partition method\n *\n * has a base case of a list of size 1 or fewer\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nvoid quicksort(std::vector\nT\n \n v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate\ntypename T\n\nvoid quicksort(std::vector\nT\n \n v) {\n    quicksort(v, 0, v.size());\n}\n\n/*\n * InsertionSort\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nvoid insertionsort(std::vector\nT\n \n v, int first, int last, Compare comp = Compare()) {\n    for(int sorted = first + 1; sorted \n last; ++sorted) {\n        for(int i = sorted; i \n first \n comp(v.at(i), v.at(i-1)); --i) {\n            std::swap(v.at(i), v.at(i-1));\n        }\n    }\n}\n\n/*\n * overload\n */\ntemplate\ntypename T\n\nvoid insertionsort(std::vector\nT\n \n v) {\n    insertionsort(v, 0, v.size());\n}\n\n/*\n * uses the median of three pivot selection method and the faster partition method\n *\n * insertion sort is called for reasonably small lists\n */\ntemplate\ntypename T, typename Compare = std::less\nT\n\nvoid faster_quicksort(std::vector\nT\n \n v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate\ntypename T\n\nvoid faster_quicksort(std::vector\nT\n \n v) {\n    faster_quicksort(v, 0, v.size());\n}\n\n\n\n\n\nAn example test harness.\n\n\nExercise 1\n\n\nCreate the median_of_three function for selecting the pivot value.\nDiscuss with the people around you which three values you should pass into this function to find the best pivot value.\n\n\nDon't forget to test it!\n\n\nExercise 2\n\n\nCreate the naive_partition method.\nTest it.\n\n\nExercise 3\n\n\nCreate naive_quicksort\n\n\nTest it!\n\n\nExercise 4\n\n\nCreate partition\n\n\nTest it!1!!\n\n\nExercise 5\n\n\nCreate quicksort\n\n\nTest it!\n\n\nExercise 6\n\n\nCreate faster_quicksort\n\n\nYou are now able to run the example test harness. Do it. It is amazing.\n\n\nStretch Exercise 1\n\n\ntba\n\n\nStretch Exercise 2\n\n\ntba\n\n\nStretch Exercise 3\n\n\ntba", 
            "title": "Lab Week 8"
        }, 
        {
            "location": "/lab_week_08/#lab-week-8-quicksort", 
            "text": "Today you will be implementing Quicksort.\nFor a mediocre visualization on how Quicksort works, go  here .  The general algorithm for quicksort:  def Quicksort(L):\n    # lists of size 1 or less\n    # are sorted by definition\n    if (len(L)  = 1):\n        return\n\n    # select pivot index using\n    # the list of elements\n    pivot = selectPivot(L)\n\n    # partition into two halves\n    # using the pivot value\n    partIdx = partition(L, pivot)\n\n    # recursively sort the left\n    # and right sublists\n    Quicksort(L[:partIdx])\n    Quicksort(L[partIdx:])  Declarations for lab today:  #include  utility \n#include  algorithm \n#include  vector \n#include  functional \n#include  iostream \n#include  iterator \n\n/*\n * takes three values and uses comp to put them in sorted order.\n * the median ends up at b.\n */\ntemplate typename T, typename Compare = std::less T \nvoid median_of_three(T   a, T   b, T   c, Compare comp = Compare());\n\n/*\n * partitions v from first to last using mid as the pivot\n */\ntemplate typename T, typename Compare = std::less T \nint partition(std::vector T    v, int first, int mid, int last, Compare comp = Compare());\n\n/*\n * same as other partition;\n * creates two vectors for the left and right, then puts all the elements (except for mid)\n * in the two. Then, they are put back in v so that v is partitioned, and returns the\n * index of the pivot value.\n */\ntemplate typename T, typename Compare = std::less T \nint naive_partition(std::vector T    v, int first, int mid, int last, Compare comp = Compare());\n\n/*\n * uses the median of three pivot selection method, and the naive partition method\n * to implement quicksort\n *\n * has a base case of a list of size 1 or fewer\n */\ntemplate typename T, typename Compare = std::less T \nvoid naive_quicksort(std::vector T    v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate typename T \nvoid naive_quicksort(std::vector T    v) {\n    naive_quicksort(v, 0, v.size());\n}\n\n/*\n * uses the median of three pivot selection method, and the faster partition method\n *\n * has a base case of a list of size 1 or fewer\n */\ntemplate typename T, typename Compare = std::less T \nvoid quicksort(std::vector T    v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate typename T \nvoid quicksort(std::vector T    v) {\n    quicksort(v, 0, v.size());\n}\n\n/*\n * InsertionSort\n */\ntemplate typename T, typename Compare = std::less T \nvoid insertionsort(std::vector T    v, int first, int last, Compare comp = Compare()) {\n    for(int sorted = first + 1; sorted   last; ++sorted) {\n        for(int i = sorted; i   first   comp(v.at(i), v.at(i-1)); --i) {\n            std::swap(v.at(i), v.at(i-1));\n        }\n    }\n}\n\n/*\n * overload\n */\ntemplate typename T \nvoid insertionsort(std::vector T    v) {\n    insertionsort(v, 0, v.size());\n}\n\n/*\n * uses the median of three pivot selection method and the faster partition method\n *\n * insertion sort is called for reasonably small lists\n */\ntemplate typename T, typename Compare = std::less T \nvoid faster_quicksort(std::vector T    v, int first, int last, Compare comp = Compare());\n\n/*\n * overload\n */\ntemplate typename T \nvoid faster_quicksort(std::vector T    v) {\n    faster_quicksort(v, 0, v.size());\n}  An example test harness.", 
            "title": "Lab Week 8: QuickSort"
        }, 
        {
            "location": "/lab_week_08/#exercise-1", 
            "text": "Create the median_of_three function for selecting the pivot value.\nDiscuss with the people around you which three values you should pass into this function to find the best pivot value.  Don't forget to test it!", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_08/#exercise-2", 
            "text": "Create the naive_partition method.\nTest it.", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_08/#exercise-3", 
            "text": "Create naive_quicksort  Test it!", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/lab_week_08/#exercise-4", 
            "text": "Create partition  Test it!1!!", 
            "title": "Exercise 4"
        }, 
        {
            "location": "/lab_week_08/#exercise-5", 
            "text": "Create quicksort  Test it!", 
            "title": "Exercise 5"
        }, 
        {
            "location": "/lab_week_08/#exercise-6", 
            "text": "Create faster_quicksort  You are now able to run the example test harness. Do it. It is amazing.", 
            "title": "Exercise 6"
        }, 
        {
            "location": "/lab_week_08/#stretch-exercise-1", 
            "text": "tba", 
            "title": "Stretch Exercise 1"
        }, 
        {
            "location": "/lab_week_08/#stretch-exercise-2", 
            "text": "tba", 
            "title": "Stretch Exercise 2"
        }, 
        {
            "location": "/lab_week_08/#stretch-exercise-3", 
            "text": "tba", 
            "title": "Stretch Exercise 3"
        }, 
        {
            "location": "/lab_week_09/", 
            "text": "Lab Week 9: Graphs\n\n\nGraphs are defined as consisting of a set \nV\n of vertices\nand a set \nE\n of edges. Edges are further defined as being\neither an ordered pair of vertices (in the case of a directed\ngraph), or an unordered pair (in the case of an undirected\ngraph).\n\n\nImplementation\n\n\nThe two primary ways that graphs are implemented are as an\nadjacency matrix or as an adjacency list. An adjacency matrix\nconsists of a two dimensional array where the indices map to\nthe vertices and the intersections between every pair of vertices\nindicate whether there is an edge connecting them and if so\nwhat the weight of that edge is (in the case of a weighted\ngraph). The image below should help to illustrate this.\n\n\n\n\nThis class definition should help give you an idea of where to\nstart when implementing a graph as an adjacency matrix.\n\n\nclass AdjacencyMatrix{\n    private:\n        int n;\n        int **adj;\n        bool *visited;\n    public:\n        AdjacencyMatrix(int n);\n        ~AdjacencyMatrix();\n        void add_edge(int origin, int destin, int weight);\n        void display();\n        /* etc. */\n};\n\n\n\n\nAdjacency lists conserve more space by using lists of edges\nstored at each vertex to represent adjacencies instead of an\nn by n matrix. In an adjacency list we store a list for\n\neach node that contains the edges for that node. Each element\nin that list represents an edge in the graph and contains\ninformation such as the starting and ending vertices as well\nas the edge weight. The image below illustrates this.\n\n\n\n\nSince we need to create nodes for the vertices and edges we can\nnow add other useful attributes to each vertex to help us with our\nalgorithms. For example, a color attribute for use with a graph\ncoloring algorithm or a visited attribute for a graph traversal\nalgorithm. The implementation consists of three classes; the \n\nAdjacency_List\n class, the \nVertex\n class and the \nEdge\n class. \nIf you notice in the example below, the Vertex class contains a list\nof edges and the Edge class contains a pointer to both a starting \nand ending vertex.\n\n\nclass Vertex{\n    private:\n        vector\nEdge*\n Adjacencys;\n        int color;\n        bool visited;\n    public:\n        Vertex();\n        ~Vertex();\n};\n\nclass Edge{\n    private:\n        Vertex *from;\n        Vertex *to;\n        int weight;\n    public:\n        Edge();\n        ~Edge();\n};\n\nclass AdjacencyList{\n    private:\n        vector\nVertex*\n Vertices;\n    public:\n        Graph();\n        ~Graph();\n        void add_edge(Vertex *from, Vertex *to, int weight);\n        void add_edge(int from, int to, int weight);\n        void display();\n        /* etc. */\n};\n\n\n\n\nDFS and BFS\n\n\nDepth First Search (DFS) and Breadth First Search (BFS) are the two\nprimary search algorithms that all other algorithms use to  traverse\na graph. A depth first search will start at the given node and add\nall of the unvisited adjacent nodes to a stack. It will then mark the current node as visited and repeat the process on the next node which it pops off of the stack. This process repeats until all of the vertices have been visited and the stack is empty. A breadth first search, on the other hand, starts at the given vertex and then adds all of its adjacent vertices to a queue. When this is complete, the algorithm marks the vertex as visited and moves on the the next vertex in the queue. It repeats this process until all of the vertices have been visited and and the queue is empty. The easiest way to remember these essential algorithms is to mentally link DFS to Stacks and BFS to Queues.\n\n\nExercise 1\n\n\nImplement a Graph class using either the Adjacency Matrix or the\nAdjacency list approach. Feel free to use the code given above\nto help you get started.\n\n\nExercise 2\n\n\nA cycle is any point in a graph where it is possible to travel in a\nloop. For example; there is an edge from A to B, from B to C, and\nfrom C back to A. Write a member function that detects whether your\ngraph contains any cycles and returns true or false respectively.\n\n\nExercise 3\n\n\nWrite a member function that, given a starting vertex and an ending\nvertex, prints out a list of vertices that connect a path between\nthem.\n\n\nStretch-goal exercise:\n\n\nCan you come up with an algorithm that finds the shortest\npath between two given vertices?", 
            "title": "Lab Week 9"
        }, 
        {
            "location": "/lab_week_09/#lab-week-9-graphs", 
            "text": "Graphs are defined as consisting of a set  V  of vertices\nand a set  E  of edges. Edges are further defined as being\neither an ordered pair of vertices (in the case of a directed\ngraph), or an unordered pair (in the case of an undirected\ngraph).", 
            "title": "Lab Week 9: Graphs"
        }, 
        {
            "location": "/lab_week_09/#implementation", 
            "text": "The two primary ways that graphs are implemented are as an\nadjacency matrix or as an adjacency list. An adjacency matrix\nconsists of a two dimensional array where the indices map to\nthe vertices and the intersections between every pair of vertices\nindicate whether there is an edge connecting them and if so\nwhat the weight of that edge is (in the case of a weighted\ngraph). The image below should help to illustrate this.   This class definition should help give you an idea of where to\nstart when implementing a graph as an adjacency matrix.  class AdjacencyMatrix{\n    private:\n        int n;\n        int **adj;\n        bool *visited;\n    public:\n        AdjacencyMatrix(int n);\n        ~AdjacencyMatrix();\n        void add_edge(int origin, int destin, int weight);\n        void display();\n        /* etc. */\n};  Adjacency lists conserve more space by using lists of edges\nstored at each vertex to represent adjacencies instead of an\nn by n matrix. In an adjacency list we store a list for \neach node that contains the edges for that node. Each element\nin that list represents an edge in the graph and contains\ninformation such as the starting and ending vertices as well\nas the edge weight. The image below illustrates this.   Since we need to create nodes for the vertices and edges we can\nnow add other useful attributes to each vertex to help us with our\nalgorithms. For example, a color attribute for use with a graph\ncoloring algorithm or a visited attribute for a graph traversal\nalgorithm. The implementation consists of three classes; the  Adjacency_List  class, the  Vertex  class and the  Edge  class. \nIf you notice in the example below, the Vertex class contains a list\nof edges and the Edge class contains a pointer to both a starting \nand ending vertex.  class Vertex{\n    private:\n        vector Edge*  Adjacencys;\n        int color;\n        bool visited;\n    public:\n        Vertex();\n        ~Vertex();\n};\n\nclass Edge{\n    private:\n        Vertex *from;\n        Vertex *to;\n        int weight;\n    public:\n        Edge();\n        ~Edge();\n};\n\nclass AdjacencyList{\n    private:\n        vector Vertex*  Vertices;\n    public:\n        Graph();\n        ~Graph();\n        void add_edge(Vertex *from, Vertex *to, int weight);\n        void add_edge(int from, int to, int weight);\n        void display();\n        /* etc. */\n};", 
            "title": "Implementation"
        }, 
        {
            "location": "/lab_week_09/#dfs-and-bfs", 
            "text": "Depth First Search (DFS) and Breadth First Search (BFS) are the two\nprimary search algorithms that all other algorithms use to  traverse\na graph. A depth first search will start at the given node and add\nall of the unvisited adjacent nodes to a stack. It will then mark the current node as visited and repeat the process on the next node which it pops off of the stack. This process repeats until all of the vertices have been visited and the stack is empty. A breadth first search, on the other hand, starts at the given vertex and then adds all of its adjacent vertices to a queue. When this is complete, the algorithm marks the vertex as visited and moves on the the next vertex in the queue. It repeats this process until all of the vertices have been visited and and the queue is empty. The easiest way to remember these essential algorithms is to mentally link DFS to Stacks and BFS to Queues.", 
            "title": "DFS and BFS"
        }, 
        {
            "location": "/lab_week_09/#exercise-1", 
            "text": "Implement a Graph class using either the Adjacency Matrix or the\nAdjacency list approach. Feel free to use the code given above\nto help you get started.", 
            "title": "Exercise 1"
        }, 
        {
            "location": "/lab_week_09/#exercise-2", 
            "text": "A cycle is any point in a graph where it is possible to travel in a\nloop. For example; there is an edge from A to B, from B to C, and\nfrom C back to A. Write a member function that detects whether your\ngraph contains any cycles and returns true or false respectively.", 
            "title": "Exercise 2"
        }, 
        {
            "location": "/lab_week_09/#exercise-3", 
            "text": "Write a member function that, given a starting vertex and an ending\nvertex, prints out a list of vertices that connect a path between\nthem.", 
            "title": "Exercise 3"
        }, 
        {
            "location": "/lab_week_09/#stretch-goal-exercise", 
            "text": "Can you come up with an algorithm that finds the shortest\npath between two given vertices?", 
            "title": "Stretch-goal exercise:"
        }
    ]
}